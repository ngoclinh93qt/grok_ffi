/* automatically generated by rust-bindgen 0.59.1 */

use libc::FILE as FILE;

pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub const GRK_UNK_FMT: GRK_SUPPORTED_FILE_FMT = 0;
pub const GRK_J2K_FMT: GRK_SUPPORTED_FILE_FMT = 1;
pub const GRK_JP2_FMT: GRK_SUPPORTED_FILE_FMT = 2;
pub const GRK_PXM_FMT: GRK_SUPPORTED_FILE_FMT = 3;
pub const GRK_PGX_FMT: GRK_SUPPORTED_FILE_FMT = 4;
pub const GRK_PAM_FMT: GRK_SUPPORTED_FILE_FMT = 5;
pub const GRK_BMP_FMT: GRK_SUPPORTED_FILE_FMT = 6;
pub const GRK_TIF_FMT: GRK_SUPPORTED_FILE_FMT = 7;
pub const GRK_RAW_FMT: GRK_SUPPORTED_FILE_FMT = 8;
pub const GRK_PNG_FMT: GRK_SUPPORTED_FILE_FMT = 9;
pub const GRK_RAWL_FMT: GRK_SUPPORTED_FILE_FMT = 10;
pub const GRK_JPG_FMT: GRK_SUPPORTED_FILE_FMT = 11;
pub type GRK_SUPPORTED_FILE_FMT = ::std::os::raw::c_uint;
#[doc = "< place-holder"]
pub const GRK_PROG_UNKNOWN: _GRK_PROG_ORDER = -1;
#[doc = "< layer-resolution-component-precinct order"]
pub const GRK_LRCP: _GRK_PROG_ORDER = 0;
#[doc = "< resolution-layer-component-precinct order"]
pub const GRK_RLCP: _GRK_PROG_ORDER = 1;
#[doc = "< resolution-precinct-component-layer order"]
pub const GRK_RPCL: _GRK_PROG_ORDER = 2;
#[doc = "< precinct-component-resolution-layer order"]
pub const GRK_PCRL: _GRK_PROG_ORDER = 3;
#[doc = "< component-precinct-resolution-layer order"]
pub const GRK_CPRL: _GRK_PROG_ORDER = 4;
pub const GRK_NUM_PROGRESSION_ORDERS: _GRK_PROG_ORDER = 5;
#[doc = " Progression order"]
pub type _GRK_PROG_ORDER = ::std::os::raw::c_int;
#[doc = " Progression order"]
pub use self::_GRK_PROG_ORDER as GRK_PROG_ORDER;
#[doc = "< unknown"]
pub const GRK_CLRSPC_UNKNOWN: _GRK_COLOR_SPACE = 0;
#[doc = "< sRGB"]
pub const GRK_CLRSPC_SRGB: _GRK_COLOR_SPACE = 2;
#[doc = "< grayscale"]
pub const GRK_CLRSPC_GRAY: _GRK_COLOR_SPACE = 3;
#[doc = "< standard YCC (YUV)"]
pub const GRK_CLRSPC_SYCC: _GRK_COLOR_SPACE = 4;
#[doc = "< extended YCC"]
pub const GRK_CLRSPC_EYCC: _GRK_COLOR_SPACE = 5;
#[doc = "< CMYK"]
pub const GRK_CLRSPC_CMYK: _GRK_COLOR_SPACE = 6;
#[doc = "< default CIE LAB"]
pub const GRK_CLRSPC_DEFAULT_CIE: _GRK_COLOR_SPACE = 7;
#[doc = "< custom CIE LAB"]
pub const GRK_CLRSPC_CUSTOM_CIE: _GRK_COLOR_SPACE = 8;
#[doc = "< ICC profile"]
pub const GRK_CLRSPC_ICC: _GRK_COLOR_SPACE = 9;
#[doc = " Supported image color spaces"]
pub type _GRK_COLOR_SPACE = ::std::os::raw::c_uint;
#[doc = " Supported image color spaces"]
pub use self::_GRK_COLOR_SPACE as GRK_COLOR_SPACE;
#[doc = "< place-holder"]
pub const GRK_CODEC_UNKNOWN: _GRK_CODEC_FORMAT = -1;
#[doc = "< JPEG 2000 code stream : read/write"]
pub const GRK_CODEC_J2K: _GRK_CODEC_FORMAT = 0;
#[doc = "< JP2 file format : read/write"]
pub const GRK_CODEC_JP2: _GRK_CODEC_FORMAT = 2;
#[doc = " Supported codecs"]
pub type _GRK_CODEC_FORMAT = ::std::os::raw::c_int;
#[doc = " Supported codecs"]
pub use self::_GRK_CODEC_FORMAT as GRK_CODEC_FORMAT;
pub const GRK_TILE_CACHE_NONE: GRK_TILE_CACHE_STRATEGY = 0;
pub const GRK_TILE_CACHE_ALL: GRK_TILE_CACHE_STRATEGY = 1;
pub type GRK_TILE_CACHE_STRATEGY = ::std::os::raw::c_uint;
#[doc = " Callback function prototype for logging"]
#[doc = ""]
#[doc = " @param msg               Event message"]
#[doc = " @param client_data       Client object where will be return the event message"]
pub type grk_msg_callback = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const ::std::os::raw::c_char,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Base Grok ref-counted object"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_object {
    pub wrapper: *mut ::std::os::raw::c_void,
}
#[doc = " Base Grok ref-counted object"]
#[doc = ""]
pub type grk_object = _grk_object;
#[doc = " Progression order change"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_progression {
    #[doc = " progression order bounds specified by POC"]
    pub layS: u16,
    pub layE: u16,
    pub resS: u8,
    pub resE: u8,
    pub compS: u16,
    pub compE: u16,
    pub precS: u64,
    pub precE: u64,
    #[doc = " Progression order enum"]
    pub specifiedCompressionPocProg: GRK_PROG_ORDER,
    pub progression: GRK_PROG_ORDER,
    #[doc = " Progression order string"]
    pub progressionString: [::std::os::raw::c_char; 5usize],
    #[doc = " Tile number"]
    pub tileno: u32,
    #[doc = " Start and end values for tile width and height"]
    pub tx0: u32,
    pub tx1: u32,
    pub ty0: u32,
    pub ty1: u32,
    #[doc = " progression order bounds initialized in pi_create_compress"]
    pub tpLayE: u16,
    pub tpResS: u8,
    pub tpResE: u8,
    pub tpCompS: u16,
    pub tpCompE: u16,
    pub tpPrecE: u64,
    #[doc = " tile bounds initialized by pi_create_compress"]
    pub tp_txS: u32,
    pub tp_txE: u32,
    pub tp_tyS: u32,
    pub tp_tyE: u32,
    pub dx: u32,
    pub dy: u32,
    #[doc = " tile part temporary values initialized by pi_create_encode"]
    pub lay_temp: u16,
    pub res_temp: u8,
    pub comp_temp: u16,
    pub prec_temp: u64,
    pub tx0_temp: u32,
    pub ty0_temp: u32,
}
#[doc = " Progression order change"]
#[doc = ""]
pub type grk_progression = _grk_progression;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_raw_comp_cparameters {
    pub dx: u32,
    #[doc = " subsampling in X direction"]
    pub dy: u32,
}
pub type grk_raw_comp_cparameters = _grk_raw_comp_cparameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_raw_cparameters {
    pub width: u32,
    #[doc = " width of the raw image"]
    pub height: u32,
    #[doc = " height of the raw image"]
    pub numcomps: u16,
    #[doc = " number of components of the raw image"]
    pub prec: u8,
    #[doc = " bit depth of the raw image"]
    pub sgnd: bool,
    #[doc = " signed/unsigned raw image"]
    pub comps: *mut grk_raw_comp_cparameters,
}
pub type grk_raw_cparameters = _grk_raw_cparameters;
#[doc = " Compress parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_cparameters {
    #[doc = " size of tile: tile_size_on = false (not in argument) or = true (in argument)"]
    pub tile_size_on: bool,
    #[doc = " XTOsiz"]
    pub tx0: u32,
    #[doc = " YTOsiz"]
    pub ty0: u32,
    #[doc = " XTsiz"]
    pub t_width: u32,
    #[doc = " YTsiz"]
    pub t_height: u32,
    #[doc = " number of layers"]
    pub numlayers: u16,
    #[doc = " rate control allocation by rate/distortion curve"]
    pub allocationByRateDistoration: bool,
    #[doc = " layers rates expressed as compression ratios."]
    #[doc = "  They might be subsequently limited by the max_cs_size field"]
    pub layer_rate: [f64; 100usize],
    #[doc = " rate control allocation by fixed_PSNR quality"]
    pub allocationByQuality: bool,
    #[doc = " layer PSNR values"]
    pub layer_distortion: [f64; 100usize],
    pub comment: [*mut ::std::os::raw::c_char; 256usize],
    pub comment_len: [u16; 256usize],
    pub is_binary_comment: [bool; 256usize],
    pub num_comments: usize,
    #[doc = " csty : coding style"]
    pub csty: u8,
    pub numgbits: u8,
    #[doc = " progression order (default is LRCP)"]
    pub prog_order: GRK_PROG_ORDER,
    #[doc = " progressions"]
    pub progression: [grk_progression; 33usize],
    #[doc = " number of progression order changes (POCs), default to 0"]
    pub numpocs: u32,
    #[doc = " number of resolutions"]
    pub numresolution: u8,
    #[doc = " initial code block width  (default to 64)"]
    pub cblockw_init: u32,
    #[doc = " initial code block height (default to 64)"]
    pub cblockh_init: u32,
    #[doc = " code block style"]
    pub cblk_sty: u8,
    pub isHT: bool,
    #[doc = " 1 : use the irreversible DWT 9-7, 0 :"]
    #[doc = "  use lossless compression (default)"]
    pub irreversible: bool,
    #[doc = " region of interest: affected component in [0..3];"]
    #[doc = "  -1 indicates no ROI"]
    pub roi_compno: i32,
    #[doc = " region of interest: upshift value"]
    pub roi_shift: u32,
    pub res_spec: u32,
    #[doc = " initial precinct width"]
    pub prcw_init: [u32; 33usize],
    #[doc = " initial precinct height"]
    pub prch_init: [u32; 33usize],
    #[doc = " input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = " subimage compressing: origin image offset in x direction"]
    pub image_offset_x0: u32,
    #[doc = " subimage compressing: origin image offset in y direction"]
    pub image_offset_y0: u32,
    #[doc = " subsampling value for dx"]
    pub subsampling_dx: u32,
    #[doc = " subsampling value for dy"]
    pub subsampling_dy: u32,
    #[doc = " input file format"]
    pub decod_format: GRK_SUPPORTED_FILE_FMT,
    #[doc = " output file format"]
    pub cod_format: GRK_SUPPORTED_FILE_FMT,
    pub raw_cp: grk_raw_cparameters,
    #[doc = " Maximum size (in bytes) for each component."]
    #[doc = " If == 0, component size limitation is not considered"]
    pub max_comp_size: u32,
    #[doc = " Tile part generation"]
    pub enableTilePartGeneration: bool,
    #[doc = " new tile part progression divider"]
    pub newTilePartProgressionDivider: u8,
    #[doc = " MCT (multiple component transform)"]
    pub mct: u8,
    #[doc = " Naive implementation of MCT restricted to a single reversible array based"]
    #[doc = "compressing without offset concerning all the components."]
    pub mct_data: *mut ::std::os::raw::c_void,
    #[doc = " Maximum size (in bytes) for the whole code stream."]
    #[doc = " If equal to zero, code stream size limitation is not considered"]
    #[doc = " If it does not comply with layer_rate, max_cs_size prevails"]
    #[doc = " and a warning is issued."]
    pub max_cs_size: u64,
    #[doc = " RSIZ value"]
    #[doc = "To be used to combine GRK_PROFILE_*, GRK_EXTENSION_* and (sub)levels values."]
    pub rsiz: u16,
    pub framerate: u16,
    pub write_capture_resolution_from_file: bool,
    pub capture_resolution_from_file: [f64; 2usize],
    pub write_capture_resolution: bool,
    pub capture_resolution: [f64; 2usize],
    pub write_display_resolution: bool,
    pub display_resolution: [f64; 2usize],
    pub rateControlAlgorithm: u32,
    pub numThreads: u32,
    pub deviceId: i32,
    pub duration: u32,
    pub kernelBuildOptions: u32,
    pub repeats: u32,
    pub writePLT: bool,
    pub writeTLM: bool,
    pub verbose: bool,
}
#[doc = " Compress parameters"]
pub type grk_cparameters = _grk_cparameters;
#[doc = "Channel definition: channel index, type, association"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_channel_description {
    pub cn: u16,
    pub typ: u16,
    pub asoc: u16,
}
#[doc = "Channel definition: channel index, type, association"]
pub type grk_channel_description = _grk_channel_description;
#[doc = "Channel definitions and number of definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_channel_definition {
    pub descriptions: *mut grk_channel_description,
    pub num_channel_descriptions: u16,
}
#[doc = "Channel definitions and number of definitions"]
pub type grk_channel_definition = _grk_channel_definition;
#[doc = "Component mappings: component index, mapping type, palette column"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_component_mapping_comp {
    pub component_index: u16,
    pub mapping_type: u8,
    pub palette_column: u8,
}
#[doc = "Component mappings: component index, mapping type, palette column"]
pub type grk_component_mapping_comp = _grk_component_mapping_comp;
#[doc = "Palette data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_palette_data {
    pub lut: *mut i32,
    pub num_entries: u16,
    pub component_mapping: *mut grk_component_mapping_comp,
    pub num_channels: u8,
    pub channel_sign: *mut bool,
    pub channel_prec: *mut u8,
}
#[doc = "Palette data"]
pub type grk_palette_data = _grk_palette_data;
#[doc = "ICC profile, palette, channel definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grk_color {
    pub icc_profile_buf: *mut u8,
    pub icc_profile_len: u32,
    pub channel_definition: *mut grk_channel_definition,
    pub palette: *mut grk_palette_data,
    pub has_colour_specification_box: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grk_asoc {
    pub level: u32,
    pub label: *const ::std::os::raw::c_char,
    pub xml: *mut u8,
    pub xml_len: u32,
}
#[doc = " Header info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_header_info {
    #[doc = " initial code block width, default to 64"]
    pub cblockw_init: u32,
    #[doc = " initial code block height, default to 64"]
    pub cblockh_init: u32,
    #[doc = " 1 : use the irreversible DWT 9-7, 0 : use lossless compression (default)"]
    pub irreversible: bool,
    #[doc = " multi-component transform identifier"]
    pub mct: u32,
    #[doc = " RSIZ value"]
    #[doc = "To be used to combine GRK_PROFILE_*, GRK_EXTENSION_* and (sub)levels values."]
    pub rsiz: u16,
    #[doc = " number of resolutions"]
    pub numresolutions: u32,
    pub csty: u8,
    pub cblk_sty: u8,
    #[doc = " initial precinct width"]
    pub prcw_init: [u32; 33usize],
    #[doc = " initial precinct height"]
    pub prch_init: [u32; 33usize],
    #[doc = " XTOsiz"]
    pub tx0: u32,
    #[doc = " YTOsiz"]
    pub ty0: u32,
    #[doc = " XTsiz"]
    pub t_width: u32,
    #[doc = " YTsiz"]
    pub t_height: u32,
    #[doc = " tile grid width"]
    pub t_grid_width: u32,
    #[doc = " tile grid height"]
    pub t_grid_height: u32,
    #[doc = " number of layers"]
    pub numlayers: u16,
    pub xml_data: *mut u8,
    pub xml_data_len: usize,
    pub num_comments: usize,
    pub comment: [*mut ::std::os::raw::c_char; 256usize],
    pub comment_len: [u16; 256usize],
    pub isBinaryComment: [bool; 256usize],
    pub asocs: [grk_asoc; 256usize],
    pub num_asocs: u32,
}
#[doc = " Header info"]
pub type grk_header_info = _grk_header_info;
#[doc = " Core decompress parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_dparameters {
    #[doc = "Set the number of highest resolution levels to be discarded."]
    #[doc = "The image resolution is effectively divided by 2 to the power of the number of discarded"]
    #[doc = "levels. The reduce factor is limited by the smallest total number of decomposition levels among"]
    #[doc = "tiles. if greater than zero, then image is decoded to original dimension divided by"]
    #[doc = "2^(cp_reduce); if equal to zero or not used, image is decompressed to full resolution"]
    pub cp_reduce: u8,
    #[doc = "Set the maximum number of quality layers to decompress."]
    #[doc = "If there are fewer quality layers than the specified number, all quality layers will be"]
    #[doc = "decompressed. if != 0, then only the first \"layer\" layers are decompressed; if == 0 or not"]
    #[doc = "used, all the quality layers are decompressed"]
    pub cp_layer: u16,
    #[doc = " input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = " input file format"]
    pub decod_format: GRK_SUPPORTED_FILE_FMT,
    #[doc = " output file format"]
    pub cod_format: GRK_SUPPORTED_FILE_FMT,
    #[doc = " Decompress window left boundary"]
    pub DA_x0: u32,
    #[doc = " Decompress window right boundary"]
    pub DA_x1: u32,
    #[doc = " Decompress window up boundary"]
    pub DA_y0: u32,
    #[doc = " Decompress window bottom boundary"]
    pub DA_y1: u32,
    #[doc = " Verbose mode"]
    pub m_verbose: bool,
    #[doc = " tile number of the decompressed tile"]
    pub tileIndex: u16,
    #[doc = " Number of tiles to decompress"]
    pub nb_tile_to_decompress: u32,
    pub flags: u32,
    pub tileCacheStrategy: GRK_TILE_CACHE_STRATEGY,
}
#[doc = " Core decompress parameters"]
pub type grk_dparameters = _grk_dparameters;
pub const GRK_PREC_MODE_CLIP: grk_prec_mode = 0;
pub const GRK_PREC_MODE_SCALE: grk_prec_mode = 1;
#[doc = " Precision mode"]
pub type grk_prec_mode = ::std::os::raw::c_uint;
#[doc = " Precision mode"]
pub use self::grk_prec_mode as grk_precision_mode;
#[doc = " Precision"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_prec {
    pub prec: u8,
    pub mode: grk_precision_mode,
}
#[doc = " Precision"]
pub type grk_precision = _grk_prec;
#[doc = " Decompress parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_decompress_params {
    #[doc = " core library parameters"]
    pub core: grk_dparameters,
    #[doc = " input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = " output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = " input file format 0: J2K, 1: JP2"]
    pub decod_format: GRK_SUPPORTED_FILE_FMT,
    #[doc = " output file format 0: PGX, 1: PxM, 2: BMP"]
    pub cod_format: GRK_SUPPORTED_FILE_FMT,
    #[doc = " index file name"]
    pub indexfilename: [::std::os::raw::c_char; 4096usize],
    #[doc = " Decompress window left boundary"]
    pub DA_x0: u32,
    #[doc = " Decompress window right boundary"]
    pub DA_x1: u32,
    #[doc = " Decompress window up boundary"]
    pub DA_y0: u32,
    #[doc = " Decompress window bottom boundary"]
    pub DA_y1: u32,
    #[doc = " Verbose mode"]
    pub m_verbose: bool,
    #[doc = " tile number of the decompressed tile"]
    pub tileIndex: u16,
    #[doc = " Number of tiles to decompress"]
    pub nb_tile_to_decompress: u32,
    pub precision: *mut grk_precision,
    pub nb_precision: u32,
    pub force_rgb: bool,
    pub upsample: bool,
    pub split_pnm: bool,
    pub serialize_xml: bool,
    pub compression: u32,
    pub compressionLevel: u32,
    pub deviceId: i32,
    pub duration: u32,
    pub kernelBuildOptions: u32,
    pub repeats: u32,
    pub verbose: bool,
    pub numThreads: u32,
}
#[doc = " Decompress parameters"]
pub type grk_decompress_parameters = _grk_decompress_params;
pub type grk_codec = grk_object;
pub type grk_stream_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        numBytes: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
pub type grk_stream_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        numBytes: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> usize,
>;
pub type grk_stream_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(numBytes: u64, user_data: *mut ::std::os::raw::c_void) -> bool,
>;
pub type grk_stream_free_user_data_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
pub type grk_stream = grk_object;
pub const GRK_COMPONENT_TYPE_COLOUR: GRK_COMPONENT_TYPE = 0;
pub const GRK_COMPONENT_TYPE_OPACITY: GRK_COMPONENT_TYPE = 1;
pub const GRK_COMPONENT_TYPE_PREMULTIPLIED_OPACITY: GRK_COMPONENT_TYPE = 2;
pub const GRK_COMPONENT_TYPE_UNSPECIFIED: GRK_COMPONENT_TYPE = 65535;
pub type GRK_COMPONENT_TYPE = ::std::os::raw::c_uint;
pub const GRK_COMPONENT_ASSOC_WHOLE_IMAGE: GRK_COMPONENT_ASSOC = 0;
pub const GRK_COMPONENT_ASSOC_COLOUR_1: GRK_COMPONENT_ASSOC = 1;
pub const GRK_COMPONENT_ASSOC_COLOUR_2: GRK_COMPONENT_ASSOC = 2;
pub const GRK_COMPONENT_ASSOC_COLOUR_3: GRK_COMPONENT_ASSOC = 3;
pub const GRK_COMPONENT_ASSOC_UNASSOCIATED: GRK_COMPONENT_ASSOC = 65535;
pub type GRK_COMPONENT_ASSOC = ::std::os::raw::c_uint;
#[doc = " Image component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_image_comp {
    pub obj: grk_object,
    #[doc = " XRsiz: horizontal separation of a sample of with component with respect to the reference"]
    #[doc = " grid"]
    pub dx: u32,
    #[doc = " YRsiz: vertical separation of a sample of with component with respect to the reference grid"]
    pub dy: u32,
    #[doc = " data width"]
    pub w: u32,
    #[doc = " data stride"]
    pub stride: u32,
    #[doc = " data height"]
    pub h: u32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: u32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: u32,
    pub Xcrg: u16,
    pub Ycrg: u16,
    #[doc = " precision"]
    pub prec: u8,
    pub sgnd: bool,
    #[doc = " image component data"]
    pub data: *mut i32,
    pub type_: GRK_COMPONENT_TYPE,
    pub association: GRK_COMPONENT_ASSOC,
}
#[doc = " Image component"]
pub type grk_image_comp = _grk_image_comp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_image_meta {
    pub obj: grk_object,
    pub color: grk_color,
    pub iptc_buf: *mut u8,
    pub iptc_len: usize,
    pub xmp_buf: *mut u8,
    pub xmp_len: usize,
}
pub type grk_image_meta = _grk_image_meta;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_image {
    pub obj: grk_object,
    #[doc = " XOsiz: horizontal offset from the origin of the reference grid"]
    #[doc = "  to the left side of the image area"]
    pub x0: u32,
    #[doc = " YOsiz: vertical offset from the origin of the reference grid"]
    #[doc = "  to the top side of the image area"]
    pub y0: u32,
    #[doc = " Xsiz: width of the reference grid"]
    pub x1: u32,
    #[doc = " Ysiz: height of the reference grid"]
    pub y1: u32,
    #[doc = " number of components in the image"]
    pub numcomps: u16,
    pub color_space: GRK_COLOR_SPACE,
    pub color_applied: bool,
    pub has_capture_resolution: bool,
    pub capture_resolution: [f64; 2usize],
    pub has_display_resolution: bool,
    pub display_resolution: [f64; 2usize],
    pub meta: *mut grk_image_meta,
    pub comps: *mut grk_image_comp,
}
pub type grk_image = _grk_image;
#[doc = " Image component parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_image_comptparm {
    #[doc = " XRsiz: horizontal separation of a sample of component"]
    #[doc = "  with respect to the reference grid"]
    pub dx: u32,
    #[doc = " YRsiz: vertical separation of a sample of component"]
    #[doc = "  with respect to the reference grid"]
    pub dy: u32,
    #[doc = " data width"]
    pub w: u32,
    pub stride: u32,
    #[doc = " data height"]
    pub h: u32,
    #[doc = " x component offset compared to the whole image"]
    pub x0: u32,
    #[doc = " y component offset compared to the whole image"]
    pub y0: u32,
    #[doc = " precision"]
    pub prec: u8,
    #[doc = " true if data is signed"]
    pub sgnd: bool,
}
#[doc = " Image component parameters"]
pub type grk_image_cmptparm = _grk_image_comptparm;
#[doc = " Plugin pass"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_pass {
    pub distortionDecrease: f64,
    pub rate: usize,
    pub length: usize,
}
#[doc = " Plugin pass"]
pub type grk_plugin_pass = _grk_plugin_pass;
#[doc = " Plugin code block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_code_block {
    #[doc = ""]
    pub x0: u32,
    #[doc = ""]
    pub y0: u32,
    #[doc = ""]
    pub x1: u32,
    #[doc = ""]
    pub y1: u32,
    pub contextStream: *mut ::std::os::raw::c_uint,
    #[doc = ""]
    pub numPix: u32,
    pub compressedData: *mut u8,
    pub compressedDataLength: u32,
    pub numBitPlanes: u8,
    pub numPasses: usize,
    pub passes: [grk_plugin_pass; 67usize],
    pub sortedIndex: ::std::os::raw::c_uint,
}
#[doc = " Plugin code block"]
pub type grk_plugin_code_block = _grk_plugin_code_block;
#[doc = " Plugin precinct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_precinct {
    pub numBlocks: u64,
    pub blocks: *mut *mut grk_plugin_code_block,
}
#[doc = " Plugin precinct"]
pub type grk_plugin_precinct = _grk_plugin_precinct;
#[doc = " Plugin band"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_band {
    pub orientation: u8,
    pub numPrecincts: u64,
    pub precincts: *mut *mut grk_plugin_precinct,
    pub stepsize: f32,
}
#[doc = " Plugin band"]
pub type grk_plugin_band = _grk_plugin_band;
#[doc = " Plugin resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_resolution {
    pub level: usize,
    pub numBands: usize,
    pub band: *mut *mut grk_plugin_band,
}
#[doc = " Plugin resolution"]
pub type grk_plugin_resolution = _grk_plugin_resolution;
#[doc = " Plugin tile component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grk_plugin_tile_component {
    pub numResolutions: usize,
    pub resolutions: *mut *mut grk_plugin_resolution,
}
#[doc = " Plugin tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_tile {
    pub decompress_flags: u32,
    pub numComponents: usize,
    pub tileComponents: *mut *mut grk_plugin_tile_component,
}
#[doc = " Plugin tile"]
pub type grk_plugin_tile = _grk_plugin_tile;
extern "C" {
    #[doc = " library version"]
    pub fn grk_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize library"]
    #[doc = ""]
    #[doc = " @param pluginPath \tpath to plugin"]
    #[doc = " @param numthreads \tnumber of threads to use for compress/decompress"]
    pub fn grk_initialize(pluginPath: *const ::std::os::raw::c_char, numthreads: u32) -> bool;
}
extern "C" {
    #[doc = " De-initialize library"]
    pub fn grk_deinitialize();
}
extern "C" {
    #[doc = " Increment ref count"]
    pub fn grk_object_ref(obj: *mut grk_object);
}
extern "C" {
    pub fn grk_object_unref(obj: *mut grk_object);
}
extern "C" {
    #[doc = " Set info handler"]
    #[doc = ""]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param user_data   client object where will be returned the message"]
    pub fn grk_set_info_handler(
        p_callback: grk_msg_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Set warning handler"]
    #[doc = ""]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param user_data   client object where will be returned the message"]
    pub fn grk_set_warning_handler(
        p_callback: grk_msg_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Set error handler"]
    #[doc = ""]
    #[doc = " @param p_callback    the callback function which will be used"]
    #[doc = " @param user_data   client object where will be returned the message"]
    pub fn grk_set_error_handler(
        p_callback: grk_msg_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Create image"]
    #[doc = ""]
    #[doc = " @param numcmpts      number of components"]
    #[doc = " @param cmptparms     component parameters"]
    #[doc = " @param clrspc        image color space"]
    #[doc = " @param allocData\t\ttrue if data is to be allocated, otherwise false"]
    #[doc = ""]
    #[doc = " @return returns      a new image if successful, otherwise nullptr"]
    pub fn grk_image_new(
        numcmpts: u16,
        cmptparms: *mut grk_image_cmptparm,
        clrspc: GRK_COLOR_SPACE,
        allocData: bool,
    ) -> *mut grk_image;
}
extern "C" {
    pub fn grk_image_meta_new() -> *mut grk_image_meta;
}
extern "C" {
    #[doc = " Deallocate all component data for an image"]
    #[doc = ""]
    #[doc = " @param image         image"]
    pub fn grk_image_all_components_data_free(image: *mut grk_image);
}
extern "C" {
    #[doc = " Deallocate data for single image component"]
    #[doc = ""]
    #[doc = " @param image         image"]
    pub fn grk_image_single_component_data_free(image: *mut grk_image_comp);
}
extern "C" {
    #[doc = " Create an abstract stream. This function does nothing except"]
    #[doc = " allocate memory and initialize abstract stream."]
    #[doc = ""]
    #[doc = " @param\tbuffer_size   size of stream's double-buffer"]
    #[doc = " @param\tis_input\t  if set to true then the stream will be"]
    #[doc = "  an input stream, an output stream else."]
    #[doc = ""]
    #[doc = " @return\tstream object."]
    pub fn grk_stream_new(buffer_size: usize, is_input: bool) -> *mut grk_stream;
}
extern "C" {
    #[doc = " Set the given function to be used as a read function."]
    #[doc = ""]
    #[doc = " @param\t\tstream\tthe stream to modify"]
    #[doc = " @param\t\tp_function\tthe function to use a read function."]
    pub fn grk_stream_set_read_function(stream: *mut grk_stream, p_function: grk_stream_read_fn);
}
extern "C" {
    #[doc = " Set the given function to be used as a write function."]
    #[doc = ""]
    #[doc = " @param\t\tstream\tthe stream to modify"]
    #[doc = " @param\t\tp_function\tthe function to use a write function."]
    pub fn grk_stream_set_write_function(stream: *mut grk_stream, p_function: grk_stream_write_fn);
}
extern "C" {
    #[doc = " Set the given function to be used as a seek function, the stream is then seekable."]
    #[doc = ""]
    #[doc = " @param\t\tstream\tthe stream to modify"]
    #[doc = " @param\t\tp_function\tthe function to use a skip function."]
    pub fn grk_stream_set_seek_function(stream: *mut grk_stream, p_function: grk_stream_seek_fn);
}
extern "C" {
    #[doc = " Set the given data to be used as a user data for the stream."]
    #[doc = ""]
    #[doc = " @param\t\tstream\tthe stream to modify"]
    #[doc = " @param\t\tdata\t\tthe data to set."]
    #[doc = " @param\t\tp_function\tthe function to free data when grk_object_unref() is called."]
    pub fn grk_stream_set_user_data(
        stream: *mut grk_stream,
        data: *mut ::std::os::raw::c_void,
        p_function: grk_stream_free_user_data_fn,
    );
}
extern "C" {
    #[doc = " Set the length of the user data for the stream."]
    #[doc = ""]
    #[doc = " @param stream    the stream to modify"]
    #[doc = " @param data_length length of the user_data."]
    pub fn grk_stream_set_user_data_length(stream: *mut grk_stream, data_length: u64);
}
extern "C" {
    #[doc = " Create stream from a file identified with its filename with a specific buffer size"]
    #[doc = ""]
    #[doc = " @param fname             the filename of the file to stream"]
    #[doc = " @param buffer_size     size of the chunk used to stream"]
    #[doc = " @param is_read_stream  whether the stream is a read stream (true) or not (false)"]
    pub fn grk_stream_create_file_stream(
        fname: *const ::std::os::raw::c_char,
        buffer_size: usize,
        is_read_stream: bool,
    ) -> *mut grk_stream;
}
extern "C" {
    #[doc = " Create stream from buffer"]
    #[doc = ""]
    #[doc = " @param buf\t\t\tbuffer"]
    #[doc = " @param buffer_len    length of buffer"]
    #[doc = " @param ownsBuffer\tif true, library will delete[] buffer. Otherwise, it is the caller's"]
    #[doc = "\t\t\t\t\t\tresponsibility to delete the buffer"]
    #[doc = " @param is_read_stream  whether the stream is a read stream (true) or not (false)"]
    pub fn grk_stream_create_mem_stream(
        buf: *mut u8,
        buffer_len: usize,
        ownsBuffer: bool,
        is_read_stream: bool,
    ) -> *mut grk_stream;
}
extern "C" {
    #[doc = " Get length of memory stream"]
    #[doc = ""]
    #[doc = " @param stream memory stream"]
    pub fn grk_stream_get_write_mem_stream_length(stream: *mut grk_stream) -> usize;
}
extern "C" {
    #[doc = " Create mapped file stream"]
    #[doc = ""]
    #[doc = " @param fname\t\t\tfile name"]
    #[doc = " @param read_stream \ttrue if this is a read stream, otherwise false"]
    pub fn grk_stream_create_mapped_file_stream(
        fname: *const ::std::os::raw::c_char,
        read_stream: bool,
    ) -> *mut grk_stream;
}
extern "C" {
    #[doc = " Create J2K/JP2 decompression structure"]
    #[doc = ""]
    #[doc = " @param format \t\tJPEG 2000 format"]
    #[doc = " @param\tstream\tJPEG 2000 stream."]
    #[doc = ""]
    #[doc = " @return a handle to a decompressor if successful, otherwise nullptr"]
    pub fn grk_decompress_create(
        format: GRK_CODEC_FORMAT,
        stream: *mut grk_stream,
    ) -> *mut grk_codec;
}
extern "C" {
    #[doc = " Initialize decompress parameters with default values"]
    #[doc = ""]
    #[doc = " @param parameters decompression parameters"]
    pub fn grk_decompress_set_default_params(parameters: *mut grk_dparameters);
}
extern "C" {
    #[doc = " Set up the decompressor with decompress parameters"]
    #[doc = ""]
    #[doc = " @param codec \t\tdecompressor handler"]
    #[doc = " @param parameters \tdecompression parameters"]
    #[doc = ""]
    #[doc = " @return true\t\t\tif the decompressor is correctly set"]
    pub fn grk_decompress_init(codec: *mut grk_codec, parameters: *mut grk_dparameters) -> bool;
}
extern "C" {
    #[doc = " Decompress JPEG 2000 header"]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t\t\tJPEG 2000 code stream to read."]
    #[doc = " @param\theader_info\t\t\tinformation read from JPEG 2000 header."]
    #[doc = " @param\timage\t\t\t\tthe image structure initialized with the characteristics"]
    #[doc = "\t\t\t\t\t\t\t\tof encoded image."]
    #[doc = " @return true\t\t\t\t\tif the main header of the code stream and the JP2 header"]
    #[doc = " \t\t\t\t\t\t\t \tis correctly read."]
    pub fn grk_decompress_read_header(
        codec: *mut grk_codec,
        header_info: *mut grk_header_info,
    ) -> bool;
}
extern "C" {
    #[doc = " Get decompressed tile image"]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t\t\tJPEG 2000 code stream to read."]
    #[doc = " @param\ttileIndex\t\t\ttile index"]
    #[doc = ""]
    #[doc = " @return pointer to decompressed image"]
    pub fn grk_decompress_get_tile_image(codec: *mut grk_codec, tileIndex: u16) -> *mut grk_image;
}
extern "C" {
    #[doc = " Get decompressed composite image"]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t\t\tJPEG 2000 code stream to read."]
    #[doc = ""]
    #[doc = " @return pointer to decompressed image"]
    pub fn grk_decompress_get_composited_image(codec: *mut grk_codec) -> *mut grk_image;
}
extern "C" {
    #[doc = " Set the given area to be decompressed. This function should be called"]
    #[doc = "  right after grk_decompress_read_header is called, and before any tile header is read."]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t\tJPEG 2000 code stream."]
    #[doc = " @param\tstart_x\t\t    left position of the rectangle to decompress (in image coordinates)."]
    #[doc = " @param\tend_x\t\t\tthe right position of the rectangle to decompress (in image"]
    #[doc = " coordinates)."]
    #[doc = " @param\tstart_y\t\t    up position of the rectangle to decompress (in image coordinates)."]
    #[doc = " @param\tend_y\t\t\tbottom position of the rectangle to decompress (in image coordinates)."]
    #[doc = ""]
    #[doc = " @return\ttrue\t\t\tif the area could be set."]
    pub fn grk_decompress_set_window(
        codec: *mut grk_codec,
        start_x: u32,
        start_y: u32,
        end_x: u32,
        end_y: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Decompress image from a JPEG 2000 code stream"]
    #[doc = ""]
    #[doc = " @param p_decompressor \tdecompressor handle"]
    #[doc = " @param tile\t\t\t \ttile struct from plugin"]
    #[doc = " @return \t\t\t\t\ttrue if successful, otherwise false"]
    pub fn grk_decompress(p_decompressor: *mut grk_codec, tile: *mut grk_plugin_tile) -> bool;
}
extern "C" {
    #[doc = " Decompress a specific tile"]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t\tJPEG 2000 code stream"]
    #[doc = " @param\ttileIndex\t\tindex of the tile to be decompressed"]
    #[doc = ""]
    #[doc = " @return\t\t\t\t\ttrue if successful, otherwise false"]
    pub fn grk_decompress_tile(codec: *mut grk_codec, tileIndex: u16) -> bool;
}
extern "C" {
    #[doc = " End decompression"]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t\tJPEG 2000 code stream"]
    pub fn grk_decompress_end(codec: *mut grk_codec) -> bool;
}
extern "C" {
    #[doc = " Creates a J2K/JP2 compression structure"]
    #[doc = " @param \tformat \t\tCoder to select"]
    #[doc = " @param\tstream\tthe JPEG 2000 stream."]
    #[doc = " @return \t\t\t\tReturns a handle to a compressor if successful,"]
    #[doc = " \t\t\t\t\t\treturns nullptr otherwise"]
    pub fn grk_compress_create(format: GRK_CODEC_FORMAT, stream: *mut grk_stream)
        -> *mut grk_codec;
}
extern "C" {
    #[doc = "Set compressing parameters to default values, that means :"]
    #[doc = ""]
    #[doc = "Lossless"]
    #[doc = "Single tile"]
    #[doc = "Size of precinct : 2^15 x 2^15 (i.e. single precinct)"]
    #[doc = "Size of code block : 64 x 64"]
    #[doc = "Number of resolutions: 6"]
    #[doc = "No SOP marker in the code stream"]
    #[doc = "No EPH marker in the code stream"]
    #[doc = "No sub-sampling in x or y direction"]
    #[doc = "No mode switch activated"]
    #[doc = "Progression order: LRCP"]
    #[doc = "No index file"]
    #[doc = "No ROI upshifted"]
    #[doc = "Image origin lies at (0,0)"]
    #[doc = "Tile origin lies at (0,0)"]
    #[doc = "Reversible DWT 5-3 transform"]
    #[doc = ""]
    #[doc = "@param parameters Compression parameters"]
    pub fn grk_compress_set_default_params(parameters: *mut grk_cparameters);
}
extern "C" {
    #[doc = " Set up the compressor parameters using the current image and user parameters."]
    #[doc = ""]
    #[doc = " @param codec \t\tJPEG 2000 code stream"]
    #[doc = " @param parameters \tcompression parameters"]
    #[doc = " @param image \t\tinput image"]
    pub fn grk_compress_init(
        codec: *mut grk_codec,
        parameters: *mut grk_cparameters,
        image: *mut grk_image,
    ) -> bool;
}
extern "C" {
    #[doc = " Start compressing current image."]
    #[doc = ""]
    #[doc = " @param codec \t\tCompressor handle"]
    #[doc = ""]
    pub fn grk_compress_start(codec: *mut grk_codec) -> bool;
}
extern "C" {
    #[doc = " Encode an image into a JPEG 2000 code stream"]
    #[doc = " @param codec \t\tcompressor handle"]
    #[doc = ""]
    #[doc = " @return \t\t\t\tReturns true if successful, returns false otherwise"]
    pub fn grk_compress(codec: *mut grk_codec) -> bool;
}
extern "C" {
    #[doc = " Compress uncompressed data stored in a buffer."]
    #[doc = " This method should be called right after grk_compress_start,"]
    #[doc = " and before grk_end_compress."]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t    JPEG 2000 code stream"]
    #[doc = " @param\ttileIndex\t\tthe index of the tile to write. At the moment,"]
    #[doc = " \t\t\t\t\t\t\tthe tiles must be written from 0 to n-1 in sequence."]
    #[doc = " @param\tdata\t\t\tpointer to the data to write. Data is arranged in planar"]
    #[doc = "  \t\t\t\t\t\tsequence, data_comp0, data_comp1 etc,"]
    #[doc = "  \t\t\t\t\t\tThe data should NOT BE INTERLEAVED."]
    #[doc = " @param\tdata_size\t\tthis value is used to ensure the data"]
    #[doc = " \t\t\t\t\t\t\tbeing written is correct. The size must be"]
    #[doc = " \t\t\t\t\t\t\tequal to the sum for each component of"]
    #[doc = "                          tile_width * tile_height * component_size."]
    #[doc = "                          component_size can be 1 or 2 bytes, depending on"]
    #[doc = "                          the precision of the given component."]
    #[doc = ""]
    #[doc = " @return\ttrue if the data could be written."]
    pub fn grk_compress_tile(
        codec: *mut grk_codec,
        tileIndex: u16,
        data: *mut u8,
        data_size: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Encode an image into a JPEG 2000 code stream using plugin"]
    #[doc = " @param codec \t\tcompressor handle"]
    #[doc = " @param tile\t\t\tplugin tile"]
    #[doc = ""]
    #[doc = " @return \t\t\t\tReturns true if successful, returns false otherwise"]
    pub fn grk_compress_with_plugin(codec: *mut grk_codec, tile: *mut grk_plugin_tile) -> bool;
}
extern "C" {
    #[doc = " End to compress the current image."]
    #[doc = " @param codec \t\tCompressor handle"]
    pub fn grk_compress_end(codec: *mut grk_codec) -> bool;
}
extern "C" {
    #[doc = " Dump codec information to file"]
    #[doc = ""]
    #[doc = " @param\tcodec\t\t\tJPEG 2000 code stream."]
    #[doc = " @param\tinfo_flag\t\ttype of information dump."]
    #[doc = " @param\toutput_stream\toutput stream where dump the information get from the codec."]
    #[doc = ""]
    pub fn grk_dump_codec(codec: *mut grk_codec, info_flag: u32, output_stream: *mut FILE);
}
extern "C" {
    #[doc = " Set the MCT matrix to use."]
    #[doc = ""]
    #[doc = " @param\tparameters\t\tthe parameters to change."]
    #[doc = " @param\tpEncodingMatrix\tthe compressing matrix."]
    #[doc = " @param\tp_dc_shift\t\tthe dc shift coefficients to use."]
    #[doc = " @param\tpNbComp\t\t\tthe number of components of the image."]
    #[doc = ""]
    #[doc = " @return\ttrue if the parameters could be set."]
    pub fn grk_set_MCT(
        parameters: *mut grk_cparameters,
        pEncodingMatrix: *mut f32,
        p_dc_shift: *mut i32,
        pNbComp: u32,
    ) -> bool;
}
#[doc = "Plugin Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_load_info {
    pub pluginPath: *const ::std::os::raw::c_char,
}
#[doc = "Plugin Interface"]
pub type grk_plugin_load_info = _grk_plugin_load_info;
extern "C" {
    #[doc = " Load plugin"]
    #[doc = ""]
    #[doc = " @param info\t\tplugin loading info"]
    pub fn grk_plugin_load(info: grk_plugin_load_info) -> bool;
}
extern "C" {
    #[doc = " Release plugin resources"]
    pub fn grk_plugin_cleanup();
}
extern "C" {
    #[doc = " Get debug state of plugin"]
    pub fn grk_plugin_get_debug_state() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_init_info {
    pub deviceId: i32,
    pub verbose: bool,
}
pub type grk_plugin_init_info = _grk_plugin_init_info;
extern "C" {
    #[doc = " Initialize plugin"]
    pub fn grk_plugin_init(initInfo: grk_plugin_init_info) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grk_plugin_compress_user_callback_info {
    pub input_file_name: *const ::std::os::raw::c_char,
    pub outputFileNameIsRelative: bool,
    pub output_file_name: *const ::std::os::raw::c_char,
    pub compressor_parameters: *mut grk_cparameters,
    pub image: *mut grk_image,
    pub tile: *mut grk_plugin_tile,
    pub compressBuffer: *mut u8,
    pub compressBufferLen: usize,
    pub error_code: ::std::os::raw::c_uint,
    pub transferExifTags: bool,
}
pub type GRK_PLUGIN_COMPRESS_USER_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(info: *mut grk_plugin_compress_user_callback_info) -> bool,
>;
extern "C" {
    #[doc = " Compress with plugin"]
    #[doc = ""]
    #[doc = " @param compress_parameters \tcompress parameters"]
    #[doc = " @param callback\t\t\t\tcallback"]
    pub fn grk_plugin_compress(
        compress_parameters: *mut grk_cparameters,
        callback: GRK_PLUGIN_COMPRESS_USER_CALLBACK,
    ) -> i32;
}
extern "C" {
    #[doc = " Batch compress with plugin"]
    #[doc = ""]
    #[doc = " @param input_dir\t\t\t\tdirectory holding input images"]
    #[doc = " @param output_dir\t\t\tdirectory holding compressed output images"]
    #[doc = " @param compress_parameters \tcompress parameters"]
    #[doc = " @param callback\t\t\t\tcallback"]
    #[doc = ""]
    #[doc = " @return 0 if successful"]
    #[doc = ""]
    pub fn grk_plugin_batch_compress(
        input_dir: *const ::std::os::raw::c_char,
        output_dir: *const ::std::os::raw::c_char,
        compress_parameters: *mut grk_cparameters,
        callback: GRK_PLUGIN_COMPRESS_USER_CALLBACK,
    ) -> i32;
}
extern "C" {
    #[doc = " Check if batch job is complete"]
    pub fn grk_plugin_is_batch_complete() -> bool;
}
extern "C" {
    #[doc = " Stop batch compress"]
    pub fn grk_plugin_stop_batch_compress();
}
pub type GROK_INIT_DECOMPRESSORS = ::std::option::Option<
    unsafe extern "C" fn(
        header_info: *mut grk_header_info,
        image: *mut grk_image,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _grk_plugin_decompress_callback_info {
    pub deviceId: usize,
    pub init_decompressors_func: GROK_INIT_DECOMPRESSORS,
    pub input_file_name: *const ::std::os::raw::c_char,
    pub output_file_name: *const ::std::os::raw::c_char,
    pub decod_format: GRK_SUPPORTED_FILE_FMT,
    pub cod_format: GRK_SUPPORTED_FILE_FMT,
    pub stream: *mut grk_stream,
    pub codec: *mut grk_codec,
    pub header_info: grk_header_info,
    pub decompressor_parameters: *mut grk_decompress_parameters,
    pub image: *mut grk_image,
    pub plugin_owns_image: bool,
    pub tile: *mut grk_plugin_tile,
    pub error_code: ::std::os::raw::c_uint,
    pub decompress_flags: u32,
    pub full_image_x0: u32,
    pub full_image_y0: u32,
    pub user_data: *mut ::std::os::raw::c_void,
}
pub type grk_plugin_decompress_callback_info = _grk_plugin_decompress_callback_info;
pub type grk_plugin_decompress_callback = ::std::option::Option<
    unsafe extern "C" fn(info: *mut grk_plugin_decompress_callback_info) -> i32,
>;
extern "C" {
    #[doc = " Decompress with plugin"]
    #[doc = ""]
    #[doc = " @param decompress_parameters  decompress parameters"]
    #[doc = " @param callback  \t\t\t callback"]
    pub fn grk_plugin_decompress(
        decompress_parameters: *mut grk_decompress_parameters,
        callback: grk_plugin_decompress_callback,
    ) -> i32;
}
extern "C" {
    #[doc = " Initialize batch decompress"]
    #[doc = ""]
    #[doc = " @param input_dir input directory holding compressed images"]
    #[doc = " @param output_dir output directory holding decompressed images"]
    #[doc = " @param decompress_parameters  decompress parameters"]
    #[doc = " @param callback  \t\t\t callback"]
    #[doc = ""]
    #[doc = " @return 0 if successful"]
    pub fn grk_plugin_init_batch_decompress(
        input_dir: *const ::std::os::raw::c_char,
        output_dir: *const ::std::os::raw::c_char,
        decompress_parameters: *mut grk_decompress_parameters,
        callback: grk_plugin_decompress_callback,
    ) -> i32;
}
extern "C" {
    #[doc = " Batch decompress"]
    pub fn grk_plugin_batch_decompress() -> i32;
}
extern "C" {
    #[doc = " Stop batch decompress"]
    pub fn grk_plugin_stop_batch_decompress();
}
